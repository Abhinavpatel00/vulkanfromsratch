"#include \"reflect_utils.h\"\n"
"#include \"../external/SPIRV-Reflect/spirv_reflect.h\"\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#include <stdbool.h>\n"
"\n"
"#ifndef VK_CHECK\n"
"#define VK_CHECK(x) do { VkResult _vk_check_res = (x); if (_vk_check_res != VK_SUCCESS) return _vk_check_res; } while(0)\n"
"#endif\n"
"\n"
"typedef struct StorageImageResolverCtx {\n"
"    VkImageView view;\n"
"    VkImageLayout layout;\n"
"} StorageImageResolverCtx;\n"
"\n"
"static StorageImageResolverCtx g_storage_image_ctx;\n"
"static bool g_storage_ctx_inited = false;\n"
"\n"
"static uint32_t storage_image_resolver_fn(\n"
"    const ReflectBindingInfo* info,\n"
"    VkWriteDescriptorSet* outWrites, uint32_t maxWrites,\n"
"    VkDescriptorImageInfo* imageInfos, uint32_t maxImageInfos,\n"
"    VkDescriptorBufferInfo* bufferInfos, uint32_t maxBufferInfos)\n"
"{\n"
"    (void)bufferInfos; (void)maxBufferInfos;\n"
"    if (!g_storage_ctx_inited) return 0;\n"
"    if (info->descriptorType != VK_DESCRIPTOR_TYPE_STORAGE_IMAGE) return 0;\n"
"    if (maxWrites < 1 || maxImageInfos < info->descriptorCount) return 0;\n"
"\n"
"    for (uint32_t i = 0; i < info->descriptorCount; ++i) {\n"
"        imageInfos[i] = (VkDescriptorImageInfo){\n"
"            .sampler = VK_NULL_HANDLE,\n"
"            .imageView = g_storage_image_ctx.view,\n"
"            .imageLayout = g_storage_image_ctx.layout,\n"
"        };\n"
"    }\n"
"    outWrites[0] = (VkWriteDescriptorSet){\n"
"        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n"
"        .dstBinding = info->binding,\n"
"        .dstArrayElement = 0,\n"
"        .descriptorCount = info->descriptorCount,\n"
"        .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,\n"
"        .pImageInfo = imageInfos,\n"
"    };\n"
"    return 1;\n"
"}\n"
"\n"
"ReflectResourceResolver reflect_make_storage_image_resolver(VkImageView imageView, VkImageLayout layout)\n"
"{\n"
"    g_storage_image_ctx.view = imageView;\n"
"    g_storage_image_ctx.layout = layout;\n"
"    g_storage_ctx_inited = true;\n"
"    return storage_image_resolver_fn;\n"
"}\n"
"\n"
"static VkDescriptorType refl_desc_type(SpvReflectDescriptorType t)\n"
"{\n"
"    switch (t) {\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_SAMPLER: return VK_DESCRIPTOR_TYPE_SAMPLER;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: return VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_SAMPLED_IMAGE: return VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_STORAGE_IMAGE: return VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: return VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: return VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_UNIFORM_BUFFER: return VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_STORAGE_BUFFER: return VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: return VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: return VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC;\n"
"    case SPV_REFLECT_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: return VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;\n"
"    default: return VK_DESCRIPTOR_TYPE_MAX_ENUM;\n"
"    }\n"
"}\n"
"\n"
"VkResult reflect_build_descriptors_from_spirv(\n"
"    VkDevice device,\n"
"    const void* spirv, size_t sizeBytes,\n"
"    ReflectedDescriptors* out,\n"
"    ReflectResourceResolver resolver)\n"
"{\n"
"    memset(out, 0, sizeof(*out));\n"
"    SpvReflectShaderModule module;\n"
"    SpvReflectResult rr = spvReflectCreateShaderModule(sizeBytes, spirv, &module);\n"
"    if (rr != SPV_REFLECT_RESULT_SUCCESS) return VK_ERROR_INITIALIZATION_FAILED;\n"
"\n"
"    uint32_t set_count = 0;\n"
"    rr = spvReflectEnumerateDescriptorSets(&module, &set_count, NULL);\n"
"    if (rr != SPV_REFLECT_RESULT_SUCCESS) { spvReflectDestroyShaderModule(&module); return VK_ERROR_INITIALIZATION_FAILED; }\n"
"\n"
"    SpvReflectDescriptorSet** sets = NULL;\n"
"    if (set_count > 0) {\n"
"        sets = (SpvReflectDescriptorSet**)malloc(sizeof(SpvReflectDescriptorSet*) * set_count);\n"
"        rr = spvReflectEnumerateDescriptorSets(&module, &set_count, sets);\n"
"        if (rr != SPV_REFLECT_RESULT_SUCCESS) { free(sets); spvReflectDestroyShaderModule(&module); return VK_ERROR_INITIALIZATION_FAILED; }\n"
"    }\n"
"\n"
"    // Determine max set index\n"
"    uint32_t max_set = 0;\n"
"    for (uint32_t i = 0; i < set_count; ++i) {\n"
"        if (sets[i]->set > max_set) max_set = sets[i]->set;\n"
"    }\n"
"    out->setLayoutCount = (set_count == 0) ? 0u : (max_set + 1u);\n"
"    if (out->setLayoutCount) {\n"
"        out->setLayouts = (VkDescriptorSetLayout*)calloc(out->setLayoutCount, sizeof(VkDescriptorSetLayout));\n"
"    }\n"
"\n"
"    // Collect pool sizes\n"
"    VkDescriptorPoolSize poolSizes[128];\n"
"    uint32_t poolSizeCount = 0;\n"
"    auto add_pool = [&](VkDescriptorType t, uint32_t cnt){\n"
"        if (t == VK_DESCRIPTOR_TYPE_MAX_ENUM || cnt == 0) return;\n"
"        for (uint32_t i = 0; i < poolSizeCount; ++i) { if (poolSizes[i].type == t) { poolSizes[i].descriptorCount += cnt; return; } }\n"
"        if (poolSizeCount < (uint32_t)(sizeof(poolSizes)/sizeof(poolSizes[0]))) poolSizes[poolSizeCount++] = (VkDescriptorPoolSize){ .type = t, .descriptorCount = cnt };\n"
"    };\n"
"\n"
"    // Create layouts, including empty ones for gaps\n"
"    for (uint32_t set_idx = 0; set_idx < out->setLayoutCount; ++set_idx) {\n"
"        SpvReflectDescriptorSet* s = NULL;\n"
"        for (uint32_t i = 0; i < set_count; ++i) if (sets[i]->set == set_idx) { s = sets[i]; break; }\n"
"        if (!s || s->binding_count == 0) {\n"
"            VkDescriptorSetLayoutCreateInfo lci = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, .bindingCount = 0, .pBindings = NULL };\n"
"            VK_CHECK(vkCreateDescriptorSetLayout(device, &lci, NULL, &out->setLayouts[set_idx]));\n"
"            continue;\n"
"        }\n"
"        VkDescriptorSetLayoutBinding* bindings = (VkDescriptorSetLayoutBinding*)calloc(s->binding_count, sizeof(VkDescriptorSetLayoutBinding));\n"
"        for (uint32_t bi = 0; bi < s->binding_count; ++bi) {\n"
"            SpvReflectDescriptorBinding* b = s->bindings[bi];\n"
"            VkDescriptorType dt = refl_desc_type(b->descriptor_type);\n"
"            uint32_t cnt = (b->count == 0 ? 1u : b->count);\n"
"            bindings[bi] = (VkDescriptorSetLayoutBinding){ .binding = b->binding, .descriptorType = dt, .descriptorCount = cnt, .stageFlags = (VkShaderStageFlagBits)module.shader_stage };\n"
"            add_pool(dt, cnt);\n"
"        }\n"
"        VkDescriptorSetLayoutCreateInfo lci = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, .bindingCount = s->binding_count, .pBindings = bindings };\n"
"        VK_CHECK(vkCreateDescriptorSetLayout(device, &lci, NULL, &out->setLayouts[set_idx]));\n"
"        free(bindings);\n"
"    }\n"
"\n"
"    if (out->setLayoutCount > 0) {\n"
"        VkDescriptorPoolCreateInfo pci = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, .maxSets = out->setLayoutCount, .poolSizeCount = poolSizeCount, .pPoolSizes = poolSizes };\n"
"        VK_CHECK(vkCreateDescriptorPool(device, &pci, NULL, &out->pool));\n"
"        out->sets = (VkDescriptorSet*)calloc(out->setLayoutCount, sizeof(VkDescriptorSet));\n"
"        VkDescriptorSetAllocateInfo dai = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, .descriptorPool = out->pool, .descriptorSetCount = out->setLayoutCount, .pSetLayouts = out->setLayouts };\n"
"        VK_CHECK(vkAllocateDescriptorSets(device, &dai, out->sets));\n"
"    }\n"
"\n"
"    if (resolver && set_count > 0) {\n"
"        VkWriteDescriptorSet writes[128];\n"
"        VkDescriptorImageInfo imgInfos[128];\n"
"        VkDescriptorBufferInfo bufInfos[128];\n"
"        for (uint32_t i = 0; i < set_count; ++i) {\n"
"            SpvReflectDescriptorSet* s = sets[i];\n"
"            VkDescriptorSet dst = out->sets[s->set];\n"
"            for (uint32_t bi = 0; bi < s->binding_count; ++bi) {\n"
"                SpvReflectDescriptorBinding* b = s->bindings[bi];\n"
"                ReflectBindingInfo info = { .set = s->set, .binding = b->binding, .descriptorType = refl_desc_type(b->descriptor_type), .descriptorCount = (b->count == 0 ? 1u : b->count), .name = b->name, .stage = (VkShaderStageFlagBits)module.shader_stage };\n"
"                uint32_t wc = resolver(&info, writes, (uint32_t)(sizeof(writes)/sizeof(writes[0])), imgInfos, (uint32_t)(sizeof(imgInfos)/sizeof(imgInfos[0])), bufInfos, (uint32_t)(sizeof(bufInfos)/sizeof(bufInfos[0])));\n"
"                if (wc) { for (uint32_t wi = 0; wi < wc; ++wi) writes[wi].dstSet = dst; vkUpdateDescriptorSets(device, wc, writes, 0, NULL); }\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Push constants\n"
"    VkPushConstantRange pcrs[8];\n"
"    uint32_t pcr_count = 0;\n"
"    uint32_t pcb_count = 0;\n"
"    rr = spvReflectEnumeratePushConstantBlocks(&module, &pcb_count, NULL);\n"
"    if (rr == SPV_REFLECT_RESULT_SUCCESS && pcb_count > 0) {\n"
"        SpvReflectBlockVariable** pcbs = (SpvReflectBlockVariable**)malloc(sizeof(*pcbs) * pcb_count);\n"
"        if (spvReflectEnumeratePushConstantBlocks(&module, &pcb_count, pcbs) == SPV_REFLECT_RESULT_SUCCESS) {\n"
"            for (uint32_t i = 0; i < pcb_count && pcr_count < (uint32_t)(sizeof(pcrs)/sizeof(pcrs[0])); ++i) {\n"
"                pcrs[pcr_count++] = (VkPushConstantRange){ .stageFlags = (VkShaderStageFlagBits)module.shader_stage, .offset = pcbs[i]->offset, .size = pcbs[i]->size };\n"
"            }\n"
"        }\n"
"        free(pcbs);\n"
"    }\n"
"\n"
"    VkPipelineLayoutCreateInfo plci = { .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, .setLayoutCount = out->setLayoutCount, .pSetLayouts = out->setLayouts, .pushConstantRangeCount = pcr_count, .pPushConstantRanges = (pcr_count ? pcrs : NULL) };\n"
"    VK_CHECK(vkCreatePipelineLayout(device, &plci, NULL, &out->pipelineLayout));\n"
"\n"
"    if (sets) free(sets);\n"
"    spvReflectDestroyShaderModule(&module);\n"
"    return VK_SUCCESS;\n"
"}\n"
"\n"
"void reflect_destroy(VkDevice device, ReflectedDescriptors* rd)\n"
"{\n"
"    if (!rd) return;\n"
"    if (rd->sets) { free(rd->sets); rd->sets = NULL; }\n"
"    if (rd->setLayouts) { for (uint32_t i = 0; i < rd->setLayoutCount; ++i) if (rd->setLayouts[i]) vkDestroyDescriptorSetLayout(device, rd->setLayouts[i], NULL); free(rd->setLayouts); rd->setLayouts = NULL; }\n"
"    if (rd->pool) { vkDestroyDescriptorPool(device, rd->pool, NULL); rd->pool = VK_NULL_HANDLE; }\n"
"    if (rd->pipelineLayout) { vkDestroyPipelineLayout(device, rd->pipelineLayout, NULL); rd->pipelineLayout = VK_NULL_HANDLE; }\n"
"    rd->setLayoutCount = 0;\n"
"}\n"
